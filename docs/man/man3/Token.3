.TH "Token" 3 "Sat Jun 10 2017" "ECMAScript" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Token
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <token\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBDebugInfo\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBToken\fP (const \fBstd::u16string\fP &str)"
.br
.ti -1c
.RI "constexpr \fBToken\fP ()"
.br
.ti -1c
.RI "constexpr \fBToken\fP (const char *str)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (const char16_t *str)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (\fBstd::nullptr_t\fP)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (bool value)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (double value)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (\fBstd::u16string\fP *value)"
.br
.ti -1c
.RI "constexpr \fBToken\fP (const \fBToken\fP &)=default"
.br
.ti -1c
.RI "constexpr \fBToken\fP (\fBToken\fP &&)=default"
.br
.ti -1c
.RI "\fB~Token\fP ()=default"
.br
.ti -1c
.RI "constexpr \fBToken\fP & \fBoperator=\fP (const \fBToken\fP &)=default"
.br
.ti -1c
.RI "constexpr \fBToken\fP & \fBoperator=\fP (\fBToken\fP &&)=default"
.br
.ti -1c
.RI "constexpr \fBtype_t\fP \fBtype\fP () const"
.br
.ti -1c
.RI "constexpr \fBoperator type_t\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_identifier\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_identifier_name\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_reserved_word\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_keyword\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_future_reserved_word\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_punctuator\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_null_literal\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_boolean_literal\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_numeric_literal\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_string_literal\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_regular_expression_literal\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBboolean_value\fP () const"
.br
.ti -1c
.RI "constexpr double \fBnumeric_value\fP () const"
.br
.ti -1c
.RI "\fBstd::u16string\fP \fBstring_value\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBoperator==\fP (const \fBToken\fP &other) const"
.br
.ti -1c
.RI "constexpr bool \fBoperator!=\fP (const \fBToken\fP &other) const"
.br
.ti -1c
.RI "constexpr bool \fBany_of\fP (\fBstd::initializer_list\fP< \fBToken\fP > tokens) const"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> constexpr bool \fBany_of\fP (Args &&\&.\&.\&. args) const"
.br
.ti -1c
.RI "\fBoperator std::string\fP () const"
.br
.ti -1c
.RI "\fBstd::string\fP \fBto_string\fP () const"
.br
.ti -1c
.RI "void \fBprint\fP (\fBstd::ostream\fP &out) const"
.br
.ti -1c
.RI "constexpr bool \fBpreceded_by_line_terminator\fP () const"
.br
.ti -1c
.RI "constexpr void \fBset_preceded_by_line_terminator\fP ()"
.br
.ti -1c
.RI "constexpr bool \fBempty\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_empty\fP () const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBToken\fP \fBidentifier\fP (\fBstd::u16string\fP value)"
.br
.ti -1c
.RI "static \fBToken\fP \fBidentifier_name\fP (\fBstd::u16string\fP value)"
.br
.ti -1c
.RI "static constexpr \fBToken\fP \fBnull_literal\fP ()"
.br
.ti -1c
.RI "static constexpr \fBToken\fP \fBpunctuator\fP (const char *str)"
.br
.ti -1c
.RI "static \fBToken\fP \fBpunctuator\fP (const \fBstd::u16string\fP &str)"
.br
.ti -1c
.RI "static \fBToken\fP \fBnumeric_literal\fP (double value)"
.br
.ti -1c
.RI "static \fBToken\fP \fBstring_literal\fP (\fBstd::u16string\fP value)"
.br
.ti -1c
.RI "static \fBToken\fP \fBregular_expression_literal\fP (\fBstd::u16string\fP value)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBDebugInfo\fP * \fBdebug_info\fP = nullptr"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Token::Token (const \fBstd::u16string\fP & str)\fC [inline]\fP"

.SS "constexpr Token::Token ()\fC [inline]\fP"

.SS "constexpr Token::Token (const char * str)\fC [inline]\fP"

.SS "constexpr Token::Token (const char16_t * str)\fC [inline]\fP"

.SS "constexpr Token::Token (\fBstd::nullptr_t\fP)\fC [inline]\fP"

.SS "constexpr Token::Token (bool value)\fC [inline]\fP, \fC [explicit]\fP"

.SS "constexpr Token::Token (double value)\fC [inline]\fP"

.SS "constexpr Token::Token (\fBstd::u16string\fP * value)\fC [inline]\fP"

.SS "constexpr Token::Token (const \fBToken\fP &)\fC [default]\fP"

.SS "constexpr Token::Token (\fBToken\fP &&)\fC [default]\fP"

.SS "Token::~Token ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "constexpr bool Token::any_of (\fBstd::initializer_list\fP< \fBToken\fP > tokens) const\fC [inline]\fP"

.SS "template<typename\&.\&.\&. Args> constexpr bool Token::any_of (Args &&\&.\&.\&. args) const\fC [inline]\fP"

.SS "constexpr bool Token::boolean_value () const\fC [inline]\fP"

.SS "constexpr bool Token::empty () const\fC [inline]\fP"

.SS "static \fBToken\fP Token::identifier (\fBstd::u16string\fP value)\fC [inline]\fP, \fC [static]\fP"

.SS "static \fBToken\fP Token::identifier_name (\fBstd::u16string\fP value)\fC [inline]\fP, \fC [static]\fP"

.SS "constexpr bool Token::is_boolean_literal () const\fC [inline]\fP"

.SS "constexpr bool Token::is_empty () const\fC [inline]\fP"

.SS "constexpr bool Token::is_future_reserved_word () const\fC [inline]\fP"

.SS "constexpr bool Token::is_identifier () const\fC [inline]\fP"

.SS "constexpr bool Token::is_identifier_name () const\fC [inline]\fP"

.SS "constexpr bool Token::is_keyword () const\fC [inline]\fP"

.SS "constexpr bool Token::is_null_literal () const\fC [inline]\fP"

.SS "constexpr bool Token::is_numeric_literal () const\fC [inline]\fP"

.SS "constexpr bool Token::is_punctuator () const\fC [inline]\fP"

.SS "constexpr bool Token::is_regular_expression_literal () const\fC [inline]\fP"

.SS "constexpr bool Token::is_reserved_word () const\fC [inline]\fP"

.SS "constexpr bool Token::is_string_literal () const\fC [inline]\fP"

.SS "static constexpr \fBToken\fP Token::null_literal ()\fC [inline]\fP, \fC [static]\fP"

.SS "static \fBToken\fP Token::numeric_literal (double value)\fC [inline]\fP, \fC [static]\fP"

.SS "constexpr double Token::numeric_value () const\fC [inline]\fP"

.SS "Token::operator \fBstd::string\fP () const\fC [inline]\fP"

.SS "constexpr Token::operator \fBtype_t\fP () const\fC [inline]\fP"

.SS "constexpr bool Token::operator!= (const \fBToken\fP & other) const\fC [inline]\fP"

.SS "constexpr \fBToken\fP& Token::operator= (const \fBToken\fP &)\fC [default]\fP"

.SS "constexpr \fBToken\fP& Token::operator= (\fBToken\fP &&)\fC [default]\fP"

.SS "constexpr bool Token::operator== (const \fBToken\fP & other) const\fC [inline]\fP"

.SS "constexpr bool Token::preceded_by_line_terminator () const\fC [inline]\fP"

.SS "void Token::print (\fBstd::ostream\fP & out) const\fC [inline]\fP"

.SS "static constexpr \fBToken\fP Token::punctuator (const char * str)\fC [inline]\fP, \fC [static]\fP"

.SS "static \fBToken\fP Token::punctuator (const \fBstd::u16string\fP & str)\fC [inline]\fP, \fC [static]\fP"

.SS "static \fBToken\fP Token::regular_expression_literal (\fBstd::u16string\fP value)\fC [inline]\fP, \fC [static]\fP"

.SS "constexpr void Token::set_preceded_by_line_terminator ()\fC [inline]\fP"

.SS "static \fBToken\fP Token::string_literal (\fBstd::u16string\fP value)\fC [inline]\fP, \fC [static]\fP"

.SS "\fBstd::u16string\fP Token::string_value () const\fC [inline]\fP"

.SS "\fBstd::string\fP Token::to_string () const\fC [inline]\fP"

.SS "constexpr \fBtype_t\fP Token::type () const\fC [inline]\fP"

.SH "Member Data Documentation"
.PP 
.SS "\fBDebugInfo\fP* Token::debug_info = nullptr"


.SH "Author"
.PP 
Generated automatically by Doxygen for ECMAScript from the source code\&.
