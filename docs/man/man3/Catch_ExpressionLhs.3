.TH "Catch::ExpressionLhs< T >" 3 "Wed Jun 14 2017" "ECMAScript" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Catch::ExpressionLhs< T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <catch\&.hpp>\fP
.PP
Inherits \fBCatch::DecomposedExpression\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBExpressionLhs\fP (\fBResultBuilder\fP &rb, T lhs)"
.br
.ti -1c
.RI "\fBExpressionLhs\fP & \fBoperator=\fP (const \fBExpressionLhs\fP &)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsEqualTo\fP, RhsT const  & > \fBoperator==\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsNotEqualTo\fP, RhsT const  & > \fBoperator!=\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsLessThan\fP, RhsT const  & > \fBoperator<\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsGreaterThan\fP, RhsT const  & > \fBoperator>\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsLessThanOrEqualTo\fP, RhsT const  & > \fBoperator<=\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "template<typename RhsT > \fBBinaryExpression\fP< T, \fBInternal::IsGreaterThanOrEqualTo\fP, RhsT const  & > \fBoperator>=\fP (RhsT const &rhs)"
.br
.ti -1c
.RI "\fBBinaryExpression\fP< T, \fBInternal::IsEqualTo\fP, bool > \fBoperator==\fP (bool rhs)"
.br
.ti -1c
.RI "\fBBinaryExpression\fP< T, \fBInternal::IsNotEqualTo\fP, bool > \fBoperator!=\fP (bool rhs)"
.br
.ti -1c
.RI "void \fBendExpression\fP ()"
.br
.ti -1c
.RI "virtual void \fBreconstructExpression\fP (\fBstd::string\fP &dest) const \fBCATCH_OVERRIDE\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T> \fBCatch::ExpressionLhs\fP< T >::\fBExpressionLhs\fP (\fBResultBuilder\fP & rb, T lhs)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<typename T> void \fBCatch::ExpressionLhs\fP< T >::endExpression ()\fC [inline]\fP"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsNotEqualTo\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator!= (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> \fBBinaryExpression\fP<T, \fBInternal::IsNotEqualTo\fP, bool> \fBCatch::ExpressionLhs\fP< T >::operator!= (bool rhs)\fC [inline]\fP"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsLessThan\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator< (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsLessThanOrEqualTo\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator<= (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> \fBExpressionLhs\fP& \fBCatch::ExpressionLhs\fP< T >::operator= (const \fBExpressionLhs\fP< T > &)"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsEqualTo\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator== (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> \fBBinaryExpression\fP<T, \fBInternal::IsEqualTo\fP, bool> \fBCatch::ExpressionLhs\fP< T >::operator== (bool rhs)\fC [inline]\fP"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsGreaterThan\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator> (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> template<typename RhsT > \fBBinaryExpression\fP<T, \fBInternal::IsGreaterThanOrEqualTo\fP, RhsT const&> \fBCatch::ExpressionLhs\fP< T >::operator>= (RhsT const & rhs)\fC [inline]\fP"

.SS "template<typename T> virtual void \fBCatch::ExpressionLhs\fP< T >::reconstructExpression (\fBstd::string\fP & dest) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Implements \fBCatch::DecomposedExpression\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ECMAScript from the source code\&.
