.TH "StatementParser" 3 "Sat Apr 29 2017" "ECMAScript" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StatementParser
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <parser\&.h>\fP
.PP
Inherits \fBExpressionParser\fP, and \fBStatementBuilder\fP\&.
.PP
Inherited by \fBParser\fP\fC [private]\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename\&.\&.\&. Args> \fBStatementParser\fP (Args &&\&.\&.\&. args)"
.br
.ti -1c
.RI "bool \fBstatement\fP ()"
.br
.ti -1c
.RI "bool \fBblock\fP ()"
.br
.ti -1c
.RI "\fBStatementList\fP \fBstatement_list\fP ()"
.br
.ti -1c
.RI "bool \fBvariable_statement\fP ()"
.br
.ti -1c
.RI "optional< \fBVariableDeclarationList\fP > \fBvariable_declaration_list\fP ()"
.br
.ti -1c
.RI "optional< \fBVariableDeclarationList\fP > \fBvariable_declaration_list_no_in\fP ()"
.br
.ti -1c
.RI "optional< \fBVariableDeclaration\fP > \fBvariable_declaration\fP ()"
.br
.ti -1c
.RI "optional< \fBVariableDeclaration\fP > \fBvariable_declaration_no_in\fP ()"
.br
.ti -1c
.RI "bool \fBinitializer\fP ()"
.br
.ti -1c
.RI "bool \fBinitializer_no_in\fP ()"
.br
.ti -1c
.RI "bool \fBempty_statement\fP ()"
.br
.ti -1c
.RI "bool \fBexpression_statement\fP ()"
.br
.ti -1c
.RI "bool \fBif_statement\fP ()"
.br
.ti -1c
.RI "bool \fBiteration_statement\fP ()"
.br
.ti -1c
.RI "bool \fBcontinue_statement\fP ()"
.br
.ti -1c
.RI "bool \fBbreak_statement\fP ()"
.br
.ti -1c
.RI "bool \fBreturn_statement\fP ()"
.br
.ti -1c
.RI "bool \fBwith_statement\fP ()"
.br
.ti -1c
.RI "bool \fBswitch_statement\fP ()"
.br
.ti -1c
.RI "bool \fBcase_block\fP ()"
.br
.ti -1c
.RI "bool \fBcase_clauses\fP ()"
.br
.ti -1c
.RI "bool \fBcase_clause\fP ()"
.br
.ti -1c
.RI "bool \fBdefault_clause\fP ()"
.br
.ti -1c
.RI "bool \fBlabelled_statement\fP ()"
.br
.ti -1c
.RI "bool \fBthrow_statement\fP ()"
.br
.ti -1c
.RI "bool \fBtry_statement\fP ()"
.br
.ti -1c
.RI "bool \fBdebugger_statement\fP ()"
.br
.ti -1c
.RI "\fBStatement\fP \fBpop_statement\fP ()"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename\&.\&.\&. Args> StatementParser::StatementParser (Args &&\&.\&.\&. args)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool StatementParser::block ()\fC [inline]\fP"

.SS "bool StatementParser::break_statement ()\fC [inline]\fP"

.SS "bool StatementParser::case_block ()\fC [inline]\fP"

.SS "bool StatementParser::case_clause ()\fC [inline]\fP"

.SS "bool StatementParser::case_clauses ()\fC [inline]\fP"

.SS "bool StatementParser::continue_statement ()\fC [inline]\fP"

.SS "bool StatementParser::debugger_statement ()\fC [inline]\fP"

.SS "bool StatementParser::default_clause ()\fC [inline]\fP"

.SS "bool StatementParser::empty_statement ()\fC [inline]\fP"

.SS "bool StatementParser::expression_statement ()\fC [inline]\fP"

.SS "bool StatementParser::if_statement ()\fC [inline]\fP"

.SS "bool StatementParser::initializer ()\fC [inline]\fP"

.SS "bool StatementParser::initializer_no_in ()\fC [inline]\fP"

.SS "bool StatementParser::iteration_statement ()\fC [inline]\fP"

.SS "bool StatementParser::labelled_statement ()\fC [inline]\fP"

.SS "\fBStatement\fP StatementParser::pop_statement ()\fC [inline]\fP"

.SS "bool StatementParser::return_statement ()\fC [inline]\fP"

.SS "bool StatementParser::statement ()\fC [inline]\fP"

.SS "\fBStatementList\fP StatementParser::statement_list ()\fC [inline]\fP"

.SS "bool StatementParser::switch_statement ()\fC [inline]\fP"

.SS "bool StatementParser::throw_statement ()\fC [inline]\fP"

.SS "bool StatementParser::try_statement ()\fC [inline]\fP"

.SS "optional<\fBVariableDeclaration\fP> StatementParser::variable_declaration ()\fC [inline]\fP"

.SS "optional<\fBVariableDeclarationList\fP> StatementParser::variable_declaration_list ()\fC [inline]\fP"

.SS "optional<\fBVariableDeclarationList\fP> StatementParser::variable_declaration_list_no_in ()\fC [inline]\fP"

.SS "optional<\fBVariableDeclaration\fP> StatementParser::variable_declaration_no_in ()\fC [inline]\fP"

.SS "bool StatementParser::variable_statement ()\fC [inline]\fP"

.SS "bool StatementParser::with_statement ()\fC [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for ECMAScript from the source code\&.
